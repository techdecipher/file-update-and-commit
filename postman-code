/***********************
 * UTF-8 safe base64
 ***********************/
function b64decUtf8(b64){
  const bin = atob(b64.replace(/\n/g,''));
  let out = '';
  for (let i=0;i<bin.length;i++) out += '%' + ('00'+bin.charCodeAt(i).toString(16)).slice(-2);
  return decodeURIComponent(out);
}
function b64encUtf8(str){
  const utf8 = unescape(encodeURIComponent(str));
  let out = '';
  for (let i=0;i<utf8.length;i++) out += String.fromCharCode(utf8.charCodeAt(i));
  return btoa(out);
}

/***********************
 * Inputs from variables
 ***********************/
const body   = pm.response.json();
const sha    = body.sha;
let   text   = b64decUtf8(body.content);

const ROLE_ARN = pm.collectionVariables.get("role_arn");
const BUCKET   = pm.collectionVariables.get("bucket_name");
const COMMIT_MSG = pm.collectionVariables.get("commit_message") || "Postman: targeted edits";

/***********************
 * Helpers
 ***********************/
function addArnToFirstArrayAfterAnchor(fullText, anchorRegex, arn, indentSpaces = 8){
  const anchorMatch = fullText.match(anchorRegex);
  if (!anchorMatch) return fullText;
  const anchorIdx = fullText.indexOf(anchorMatch[0]);
  const afterAnchor = fullText.slice(anchorIdx);
  const openIdx = afterAnchor.indexOf('[');
  if (openIdx < 0) return fullText;
  const start = anchorIdx + openIdx + 1;
  const end   = fullText.indexOf(']', start);
  if (end < 0) return fullText;

  const inside = fullText.slice(start, end);
  if (inside.includes(`"${arn}"`)) return fullText;

  const indent = ' '.repeat(indentSpaces);
  const needsComma = inside.trim().length > 0 && !inside.trim().endsWith(',');
  const insertion = `${inside}${needsComma ? ',' : ''}\n${indent}"${arn}"`;

  return fullText.slice(0, start) + insertion + fullText.slice(end);
}

function addArnToAllPrincipalArnLists(fullText, arn){
  const re = /("aws:PrincipalArn"\s*=\s*\[)([\s\S]*?)(\])/g;
  return fullText.replace(re, (m, head, contents, tail) => {
    if (contents.includes(`"${arn}"`)) return m;
    const trimmed = contents.trim();
    const indentMatch = contents.match(/\n(\s*)[^\s]/);
    const indent = indentMatch ? indentMatch[1] : '              ';
    const needsComma = trimmed.length > 0 && !trimmed.endsWith(',');
    const injected = `${contents}${needsComma ? ',' : ''}\n${indent}"${arn}"`;
    return head + injected + tail;
  });
}

function addProjectAccessStatement(fullText, projectRoleArn, bucketName){
  if (fullText.includes('Sid       = "ProjectAccess"')) return fullText;
  const stmtStart = fullText.indexOf('Statement = [');
  if (stmtStart < 0) return fullText;
  const closeIdx = fullText.indexOf('\n    ]', stmtStart);
  if (closeIdx < 0) return fullText;

  const insertPos = closeIdx;
  const block =
`\n      ,{
        Sid       = "ProjectAccess"
        Effect    = "Allow"
        Principal = { AWS = "${projectRoleArn}" }
        Action    = ["s3:ListBucket"]
        Resource  = "arn:aws:s3:::${bucketName}"
      }`;

  return fullText.slice(0, insertPos) + block + fullText.slice(insertPos);
}

/***********************
 * Apply edits
 ***********************/
text = addArnToFirstArrayAfterAnchor(text, /name\s*=\s*\[/, ROLE_ARN, 8);
text = addArnToAllPrincipalArnLists(text, ROLE_ARN);
text = addProjectAccessStatement(text, ROLE_ARN, BUCKET);

/***********************
 * Build payload
 ***********************/
const payload = {
  message: COMMIT_MSG,
  content: b64encUtf8(text),
  sha: sha,
  branch: pm.collectionVariables.get("branch")
};

pm.collectionVariables.set("payload", JSON.stringify(payload));
pm.collectionVariables.set("sha", sha);
