/***********************
 * UTF-8 safe base64
 ***********************/
function b64decUtf8(b64){
  const bin = atob(b64.replace(/\n/g,''));
  let out = '';
  for (let i=0;i<bin.length;i++) out += '%' + ('00'+bin.charCodeAt(i).toString(16)).slice(-2);
  return decodeURIComponent(out);
}
function b64encUtf8(str){
  const utf8 = unescape(encodeURIComponent(str));
  let out = '';
  for (let i=0;i<utf8.length;i++) out += String.fromCharCode(utf8.charCodeAt(i));
  return btoa(out);
}

/***********************
 * Inputs from variables
 ***********************/
const body   = pm.response.json();
const sha    = body.sha;
let   text   = b64decUtf8(body.content);

const ROLE_ARN   = pm.collectionVariables.get("role_arn");      // e.g. arn:aws:iam::1234567890:role/project-automation-role
const BUCKET     = pm.collectionVariables.get("bucket_name");   // e.g. dev
const COMMIT_MSG = pm.collectionVariables.get("commit_message") || "Postman: targeted edits";

/***********************
 * Helpers
 ***********************/

/**
 * Utility: extract leading indent of the line that contains index 'idx'
 */
function lineIndentOf(s, idx){
  const lineStart = s.lastIndexOf('\n', idx) + 1;
  let i = lineStart, n = 0;
  while (i < s.length && s[i] === ' ') { i++; n++; }
  return n;
}

/**
 * Utility: from raw inside-[...] text, extract all quoted items.
 */
function extractQuotedItems(inside){
  const items = [];
  const re = /"([^"]+)"/g;
  let m; while ((m = re.exec(inside)) !== null) items.push(m[1]);
  return items;
}

/**
 * Pretty-print an array of string items as:
 *   headerLine[
 *     "a",
 *     "b",
 *     "c"
 *   ]
 * @param baseIndent number of spaces for the header indent ("name = [")
 * @param itemsIndent additional spaces for items (typically +2)
 */
function renderPrettyArray(items, baseIndent, itemsIndent){
  const head = ' '.repeat(baseIndent) + '[';
  const itemPad = ' '.repeat(baseIndent + itemsIndent);
  const tail = '\n' + ' '.repeat(baseIndent) + ']';
  if (items.length === 0) return head + tail;
  const body = '\n' + items.map(v => `${itemPad}"${v}"`).join(',\n');
  return head + body + tail;
}

/**
 * 1) Normalize and add ROLE_ARN to the first array after "name = ["
 *    (cmk_user_iam_arns.name), with clean formatting.
 */
function addArnToFirstArrayAfterAnchor(fullText, anchorRegex, arn, itemsIndent = 2){
  const anchorMatch = fullText.match(anchorRegex);
  if (!anchorMatch) return fullText;

  const anchorIdx   = fullText.indexOf(anchorMatch[0]);
  const afterAnchor = fullText.slice(anchorIdx);
  const openIdx     = afterAnchor.indexOf('[');
  if (openIdx < 0) return fullText;

  const start = anchorIdx + openIdx + 1;       // after '['
  const end   = fullText.indexOf(']', start);  // matching ']'
  if (end < 0) return fullText;

  // Extract/normalize items
  const inside = fullText.slice(start, end);
  let items = extractQuotedItems(inside);

  if (!items.includes(arn)) items.push(arn);

  // Indentation: align with the line that contains the '['
  const baseIndent = lineIndentOf(fullText, start);
  const pretty = renderPrettyArray(items, baseIndent, itemsIndent);

  // Replace the whole [ ... ] section (including the brackets)
  return fullText.slice(0, start - 1) + pretty + fullText.slice(end + 1);
}

/**
 * 2) Add ROLE_ARN to ALL `"aws:PrincipalArn" = [ ... ]` lists,
 *    and pretty-format each list.
 */
function addArnToAllPrincipalArnLists(fullText, arn, itemsIndent = 2){
  const re = /("aws:PrincipalArn"\s*=\s*)(\[\s*[\s\S]*?\s*\])/g;
  return fullText.replace(re, (m, head, arrayBlock) => {
    // Find raw inside
    const startBracket = arrayBlock.indexOf('[');
    const endBracket   = arrayBlock.lastIndexOf(']');
    const inside       = arrayBlock.slice(startBracket + 1, endBracket);

    let items = extractQuotedItems(inside);
    if (!items.includes(arn)) items.push(arn);

    // Base indent: indent of the line where '[' sits in the original text
    const baseIndent = lineIndentOf(m, head.length + startBracket);
    const pretty = renderPrettyArray(items, baseIndent, itemsIndent);

    return head + pretty;
  });
}

/**
 * 3) Ensure a ProjectAccess block exists for ROLE_ARN:
 *    - If a placeholder block has Principal ... ProjectDevRole => replace with ROLE_ARN
 *    - If no block exists for ROLE_ARN => append a new one at end of Statement = [ ... ]
 */
function ensureProjectAccessForRole(fullText, roleArn, bucketName){
  const blockRe = /{[\s\S]*?Sid\s*=\s*"ProjectAccess"[\s\S]*?Principal\s*=\s*{\s*AWS\s*=\s*"([^"]+)"\s*}[\s\S]*?Action\s*=\s*\[[^\]]*?\][\s\S]*?Resource\s*=\s*"arn:aws:s3:::[^"]+"\s*}/g;
  let hasForRole = false;

  let replacedText = fullText.replace(blockRe, (block) => {
    const m = block.match(/Principal\s*=\s*{\s*AWS\s*=\s*"([^"]+)"/);
    const principalArn = m ? m[1] : null;

    if (principalArn === roleArn) {
      hasForRole = true;
      return block; // already for this role
    }
    if (principalArn && /:role\/ProjectDevRole$/.test(principalArn)) {
      hasForRole = true;
      return block.replace(
        /Principal\s*=\s*{\s*AWS\s*=\s*"([^"]+)"\s*}/,
        `Principal = { AWS = "${roleArn}" }`
      );
    }
    return block;
  });

  if (hasForRole) return replacedText;

  // Append new block at end of Statement array
  const stmtStart = replacedText.indexOf('Statement = [');
  if (stmtStart < 0) return replacedText;

  // Find the closing bracket for Statement = [ ... ]
  const closeIdx = replacedText.indexOf('\n    ]', stmtStart);
  if (closeIdx < 0) return replacedText;

  const insertPos = closeIdx;
  const block =
`\n      ,{
        Sid       = "ProjectAccess"
        Effect    = "Allow"
        Principal = { AWS = "${roleArn}" }
        Action    = ["s3:ListBucket"]
        Resource  = "arn:aws:s3:::${bucketName}"
      }`;

  return replacedText.slice(0, insertPos) + block + replacedText.slice(insertPos);
}

/***********************
 * Apply edits
 ***********************/
// 1) cmk_user_iam_arns.name = [ ... ]  (normalize + add role)
text = addArnToFirstArrayAfterAnchor(text, /name\s*=\s*\[/, ROLE_ARN, 2);

// 2) All "aws:PrincipalArn" lists  (normalize + add role)
text = addArnToAllPrincipalArnLists(text, ROLE_ARN, 2);

// 3) Ensure/append ProjectAccess for this ROLE_ARN
text = ensureProjectAccessForRole(text, ROLE_ARN, BUCKET);

/***********************
 * Build payload for PUT
 ***********************/
const payload = {
  message: COMMIT_MSG,
  content: b64encUtf8(text),
  sha: sha,
  branch: pm.collectionVariables.get("branch")
};

pm.collectionVariables.set("payload", JSON.stringify(payload));
pm.collectionVariables.set("sha", sha);
